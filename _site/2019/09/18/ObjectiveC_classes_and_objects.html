<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Objective-C 的类与对象 | 沈闻欣的储物间</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Objective-C 的类与对象" />
<meta name="author" content="沈闻欣" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="我叫沈闻欣，是一名iOS开发者。" />
<meta property="og:description" content="我叫沈闻欣，是一名iOS开发者。" />
<link rel="canonical" href="http://localhost:4000/2019/09/18/ObjectiveC_classes_and_objects.html" />
<meta property="og:url" content="http://localhost:4000/2019/09/18/ObjectiveC_classes_and_objects.html" />
<meta property="og:site_name" content="沈闻欣的储物间" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-18T00:00:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/09/18/ObjectiveC_classes_and_objects.html","headline":"Objective-C 的类与对象","dateModified":"2019-09-18T00:00:00+08:00","datePublished":"2019-09-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/09/18/ObjectiveC_classes_and_objects.html"},"author":{"@type":"Person","name":"沈闻欣"},"description":"我叫沈闻欣，是一名iOS开发者。","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="沈闻欣的储物间" /></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">沈闻欣的储物间</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Objective-C 的类与对象</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-09-18T00:00:00+08:00" itemprop="datePublished">2019-09-18
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#方法" id="markdown-toc-方法">方法</a></li>
  <li><a href="#变量" id="markdown-toc-变量">变量</a>    <ul>
      <li><a href="#原子性默认值为-atomic" id="markdown-toc-原子性默认值为-atomic">原子性（默认值为 atomic）</a></li>
      <li><a href="#读写默认值为-readwrite-assign" id="markdown-toc-读写默认值为-readwrite-assign">读写（默认值为 readwrite assign）</a></li>
      <li><a href="#synthesize-和-dynamic" id="markdown-toc-synthesize-和-dynamic">@synthesize 和 @dynamic</a></li>
    </ul>
  </li>
  <li><a href="#类的扩展" id="markdown-toc-类的扩展">类的扩展</a>    <ul>
      <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
      <li><a href="#protocol" id="markdown-toc-protocol">Protocol</a></li>
      <li><a href="#category" id="markdown-toc-category">Category</a></li>
      <li><a href="#extention" id="markdown-toc-extention">Extention</a>        <ul>
          <li><a href="#给已有的类添加属性" id="markdown-toc-给已有的类添加属性">给已有的类添加属性</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#类的导入" id="markdown-toc-类的导入">类的导入</a>    <ul>
      <li><a href="#类的初始化" id="markdown-toc-类的初始化">类的初始化</a>        <ul>
          <li><a href="#load" id="markdown-toc-load">+load</a></li>
          <li><a href="#initilize" id="markdown-toc-initilize">+initilize</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>本文主要探究类与对象的基础知识</p>

<h1 id="方法">方法</h1>
<p>Objective-C 中有两种类型的方法：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AClass</span> <span class="p">:</span> <span class="nc">NSObject</span> 
<span class="c1">// 类方法
</span><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">classMethod</span><span class="p">;</span>
<span class="c1">// 实例方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">instanceMethod</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">类方法</code>又称作<code class="highlighter-rouge">静态方法</code>，可以不用创建对象来调用；而<code class="highlighter-rouge">实例方法</code>必须通过实例对象调用；</p>

<p>Objective-C 中的方法只要在 @interface 中声明，都认为是公有的；它没有绝对私有的方法，只能将方法隐藏；</p>

<p>隐藏方法的方式：</p>

<ul>
  <li>在 @implementation 中声明</li>
  <li>Category</li>
  <li>Extension</li>
</ul>

<h1 id="变量">变量</h1>

<p>苹果推荐使用 <code class="highlighter-rouge"><span class="k">@property</span></code> 来声明成员变量，作为类的属性；被声明的成员变量会在类的内部自动创建 <code class="highlighter-rouge">getter</code> 和 <code class="highlighter-rouge">setter</code> 方法，前者用于获取该属性，后者用于修改这个属性；</p>

<p>属性有两种修饰方式，一种是修饰 <code class="highlighter-rouge">getter</code> 和 <code class="highlighter-rouge">setter</code> 方法的原子性，另一种是设置读写属性；</p>

<h2 id="原子性默认值为-atomic">原子性（默认值为 atomic）</h2>

<ul>
  <li>atomic : 保证属性在读写操作的原子性，它修饰的属性在读写操作完成后一定还是一个完整的属性；也就是说，它能保证读写操作的线程安全，但不能保证整个类的线程安全；</li>
  <li>nonatomic : 非原子性，因此在普遍情况下，用它修饰的属性在读写时会更快；</li>
</ul>

<blockquote>
  <p>1.如果想要保证多线程下属性赋值的安全性，需要借助其他手段来实现；</p>

  <p>2.Swift 中默认为 atomic，且无法修改；如果一个类在 OC 中定义，它的属性在 Swift 中运行时，会被修饰为 <code class="highlighter-rouge">atomic</code></p>
</blockquote>

<p>参考链接</p>

<p>https://www.jianshu.com/p/7288eacbb1a2
https://www.jianshu.com/p/66b77270e363
https://stackoverflow.com/questions/588866/whats-the-difference-between-the-atomic-and-nonatomic-attributes
https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c</p>

<h2 id="读写默认值为-readwrite-assign">读写（默认值为 readwrite assign）</h2>

<ul>
  <li>readwrite : 可读写；</li>
  <li>readonly : 只读，只会生成 getter</li>
  <li>assign : 赋值；</li>
  <li>retain : MRC 下的持有，setter 方法将传入参数先保留，再赋值，传入参数的 retain count 会+1; ARC 下也能用，但不建议；</li>
  <li>strong : ARC 独有，强引用，除非引用它的对象被释放，否则被强引用的对象将不会被释放；</li>
  <li>weak : ARC 独有，弱引用，被它修饰的属性遵循自身的释放流程，与引用它的对象释放与否无关；</li>
  <li>copy : 拷贝，setter 方法将传入对象复制一份；</li>
</ul>

<p>同时，我们还可以使用自己定义 accessor 的名字：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@property</span> <span class="p">(</span><span class="n">getter</span><span class="o">=</span><span class="n">isFinished</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">finished</span><span class="p">;</span>
</code></pre></div></div>
<p>这种情况下，编译器生成的 getter 方法名为 isFinished，而不是 finished。</p>

<h2 id="synthesize-和-dynamic">@synthesize 和 @dynamic</h2>

<ul>
  <li>系统默认会将属性 synthesize，生成 setter 和 getter 方法；</li>
  <li>可读写(readwrite)属性实现了自己的 getter 和 setter；</li>
  <li>只读(readonly)属性实现了自己的 getter；</li>
  <li>使用 @dynamic，显式表示不希望编译器生成 getter 和 setter （例如 CoreData 中的对象）；</li>
  <li>Protocol 中定义的属性，编译器不会自动 synthesize，需要手动写；</li>
  <li>当重载父类中的属性时，也必须手动写 synthesize；</li>
</ul>

<h1 id="类的扩展">类的扩展</h1>

<h2 id="继承">继承</h2>

<p>创建子类，继承父类的属性、方法等；</p>

<h2 id="protocol">Protocol</h2>

<p>协议，类似 C++ 中的多重继承，可以让多个不同的类实现类似的接口；</p>

<h2 id="category">Category</h2>

<ul>
  <li>可以不知晓某个类的源码、无需继承，来实现扩展其功能的效果；使用场景为将方法模块化，分别在不同的文件中实现；</li>
  <li>在使用 Category 时需要注意的一点是，如果有多个命名 Category 均实现了同一个方法（即出现了命名冲突），那么这些方法在运行时只有一个会被调用，具体哪个会被调用是不确定的。因此在给已有的类（特别是 Cocoa 类）添加 Category 时，推荐的函数命名方法是加上前缀</li>
</ul>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">NSString</span> <span class="p">(</span><span class="nl">ABCEmpty</span><span class="p">)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">abc_isEmpty</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div></div>

<h2 id="extention">Extention</h2>

<ul>
  <li>可以认为是匿名的 Category；</li>
  <li>必须知晓类的源码；</li>
  <li>Extension 声明的方法必须在类的主 @implementation 区间内实现，可以避免使用有名 Category 带来的多个不必要的 implementation 段；</li>
  <li>Extension 可以在类中直接添加新的属性和实例变量，Category 需要使用其他方式才可以</li>
</ul>

<h3 id="给已有的类添加属性">给已有的类添加属性</h3>

<p>Extension 可以给类添加属性，编译器会自动生成 getter，setter 和 ivar。 Category 并不支持这些。如果使用 Category 的话，类似下面这样：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">XYZPerson</span> <span class="p">(</span><span class="nl">UDID</span><span class="p">)</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">readwrite</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">uniqueIdentifier</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">XYZPerson</span> <span class="p">(</span><span class="nl">UDID</span><span class="p">)</span>
<span class="p">...</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>尽管编译可以通过，但是当真正使用 uniqueIdentifier 时直接会导致程序崩溃。</p>

<p>如果我们手动去 synthesize 呢？像下面这样：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">XYZPerson</span> <span class="p">(</span><span class="nl">UDID</span><span class="p">)</span>
<span class="k">@synthesize</span> <span class="n">uniqueIdentifier</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>然而这样做的话，代码直接报编译错误了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@synthesize not allowed in a category's implementation
</code></pre></div></div>

<p>经过查阅网上资料，我们可以用 OC 的 Runtime 机制来实现这样的效果</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">@implementation</span> <span class="nc">XYZPerson</span> <span class="p">(</span><span class="nl">UDID</span><span class="p">)</span>
<span class="k">@dynamic</span> <span class="n">uniqueIdentifier</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUniqueIdentifier</span><span class="p">:(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="p">{</span>
     <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">uniqueIdentifier</span><span class="p">),</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">uniqueIdentifier</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">uniqueIdentifier</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span>
</code></pre></div></div>

<h1 id="类的导入">类的导入</h1>

<ul>
  <li>#include: 是C/C++导入头文件的关键字</li>
  <li>#import: 是Objective-C导入头文件的关键字；头文件会自动只导入一次，不会重复导入；</li>
  <li>@class: 告诉编译器需要知道某个类的声明，可以解决头文件的相互包含问题；使用时一般在 interface 中声明，需要在 .m 文件中引用该头文件；</li>
</ul>

<h2 id="类的初始化">类的初始化</h2>

<p>在 OC 中绝大部分类都继承自 <code class="highlighter-rouge">NSObject</code>，它有两个非常特殊的类方法 <code class="highlighter-rouge">load</code> 和 <code class="highlighter-rouge">initilize</code>，用于类的初始化</p>

<h3 id="load">+load</h3>

<p><code class="highlighter-rouge">load</code> 是在被添加到 <code class="highlighter-rouge">runtime</code> 时开始执行，父类最先执行，然后是子类，最后是 <code class="highlighter-rouge">Category</code>。又因为是直接获取函数指针来执行，不会像 <code class="highlighter-rouge">objc_msgSend</code> 一样会有方法查找的过程。</p>

<h3 id="initilize">+initilize</h3>

<p><code class="highlighter-rouge">initialize</code> 最终是通过 <code class="highlighter-rouge">objc_msgSend</code> 来执行的，<code class="highlighter-rouge">objc_msgSend</code> 会执行一系列方法查找，并且 <code class="highlighter-rouge">Category</code> 的方法会覆盖类中的方法。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>+load</th>
      <th>+initialize</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>调用时机</td>
      <td>被添加到 runtime 时</td>
      <td>收到第一条消息前，可能永远不调用</td>
    </tr>
    <tr>
      <td>调用顺序</td>
      <td>父类-&gt;子类-&gt;分类</td>
      <td>父类-&gt;子类</td>
    </tr>
    <tr>
      <td>调用次数</td>
      <td>1次</td>
      <td>多次</td>
    </tr>
    <tr>
      <td>是否需要显式调用父类实现</td>
      <td>否</td>
      <td>否</td>
    </tr>
    <tr>
      <td>是否沿用父类的实现</td>
      <td>否</td>
      <td>是</td>
    </tr>
    <tr>
      <td>分类中的实现</td>
      <td>类和分类都执行</td>
      <td>覆盖类中的方法，只执行分类的实现</td>
    </tr>
  </tbody>
</table>

<p>参考链接</p>

<p>https://www.jianshu.com/p/872447c6dc3f</p>

  </div><a class="u-url" href="/2019/09/18/ObjectiveC_classes_and_objects.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">沈闻欣的储物间</h2>
        <ul class="contact-list">
          <li class="p-name">沈闻欣</li><li><a class="u-email" href="mailto:386893640@qq.com">386893640@qq.com</a></li></ul>
      </div>

      <div class="footer-col one-half">
        <p>我叫沈闻欣，是一名iOS开发者。
</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/PatShen" title="PatShen"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
